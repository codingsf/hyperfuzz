/* rco.c written by David Wagner (daw@eecs.berkeley.edu) */

/* compile with -O3 -DNDEBUG=1 to make it run faster */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <ctype.h>
#include <assert.h>

static const char *delims = "@[]:<>(),&|~=; \t\n\r";
static const char *variable_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";
static const char *all_keywords[] = {
    "BITVECTOR",
    "BOOLEAN",
    "ARRAY",
    "OF",
    "ASSERT",
    "QUERY",
    "COUNTEREXAMPLE",
    "TRUE",
    "FALSE",
    "NOT",
    "BVSX",
    "WITH",
    "BVXOR",
    "BVNAND",
    "BVNOR",
    "BVXNOR",
    "BVPLUS",
    "BVMULT",
    "BVSUB",
    "BVUMINUS",
    "BVDIV",
    "SBVDIV",
    "BVMOD",
    "SBVMOD",
    "BVLT",
    "BVGT",
    "BVLE",
    "BVGE",
    "BVSLT",
    "BVSGT",
    "BVSLE",
    "BVSGE",
    "SBVLT",
    "SBVGT",
    "SBVLE",
    "SBVGE",
    "IF",
    "THEN",
    "ELSE",
    "ENDIF",
};

/* For debugging (in case I forgot a keyword).
 * If this fits the kind of name we expect to see generated by catchconv
 * (in particular, it starts with CV, JUMPCOND, "ov," or INPUT_MEM), return 1.
 * Otherwise, return 0.  The latter case may help us to find omissions
 * in the all_keywords list above. */
static int isnormalname(const char *p) {
    if (strncmp(p, "CV", 2) != 0 
        && strncmp(p, "ov", 2) != 0 
        && strncmp(p, "JUMPCOND", 8) != 0
        && strncmp(p, "INPUT_MEM", 9) != 0)
        return 0;
    if ('0' <= *p && *p <= '9')
        return 0;
    if (strspn(p, variable_chars) < strlen(p))
        return 0;
    return 1;
}

static unsigned int hash(const char *p) {
    unsigned int hash = 5381, c;
    while ((c = *p++) != '\0') {
        hash = ((hash << 5) + hash) ^ c;
    }
    return hash;
}

#define KW_SIZE 1021
static const char *keywords[KW_SIZE];

static void addkeyword(const char *word) {
    unsigned int h = hash(word);
    unsigned int i;
    for (i = h % KW_SIZE; keywords[i] != NULL; i = (i+h+77) % KW_SIZE)
        if (strcmp(keywords[i], word) == 0)
            assert(0);
    keywords[i] = word;
}
static void init_keywords(void) {
    int i;
    for (i=0; i<sizeof(all_keywords)/sizeof(char *); i++)
        addkeyword(all_keywords[i]);
}
static int iskeyword(const char *word) {
    unsigned int h = hash(word);
    unsigned int i;
    for (i = h % KW_SIZE; keywords[i] != NULL; i = (i+h+77) % KW_SIZE)
        if (strcmp(keywords[i], word) == 0)
            return 1;
    return 0;
}

static int isconstant(char *p) {
    int len = strlen(p);
    if (strspn(p, "0123456789") == len)
        return 1;
    if (len > 4 && strncmp(p, "0bin", 4) == 0
            && strspn(p+4, "01") == (len-4))
        return 1;
    if (len > 4 && strncmp(p, "0hex", 4) == 0
            && strspn(p+4, "0123456789ABCDEFabcdef") == (len-4))
        return 1;
    return 0;
}

/* A memory-efficient allocator.  Returns a string which must never
 * be free()d. */
static char *mystrdup(const char *s) {
#define POOLSIZE 65520
    static unsigned int used = POOLSIZE;
    static char *pool = NULL;
    unsigned int len = strlen(s);
    char *t;
    assert(len < POOLSIZE-1);
    if (used + len + 1 >= POOLSIZE) {
        pool = malloc(POOLSIZE);
        if (pool == NULL) {
            fprintf(stderr, "Out of memory trying to alloc string pool.\n");
            exit(1);
        }
        used = 0;
        /* don't free old pool (those strings are still in use) */
    }
    t = &pool[used];
    memcpy(t, s, len+1);
    used += len+1;
    return t;
#undef POOLSIZE
}

struct variable {
    const char *name;

    // for union-find data structure
    // XXX: Grody hack: Normally, we'd use .parent == NULL to
    // indicate that this is a root of the union-find forest.
    // However, we'll use any value from 0-4095 to indicate NULL,
    // and we'll overload this to hold the rank in case this is
    // a root note by using the value from 0-4095 to hold its
    // rank from 0-4095.
    struct variable *parent;
};

/* A memory-efficient allocator of 'struct variable's.  Returns a
 * pointer which must never be free()d. */
static struct variable *alloc_variable(char *name) {
    // we use our own allocater, to minimize space overhead
#define POOLSIZE 65528
    static int used = POOLSIZE;
    static struct variable *pool = NULL;
    struct variable *v;
    if (used >= POOLSIZE) {
        pool = malloc(POOLSIZE * sizeof(struct variable));
        if (pool == NULL) {
            fprintf(stderr, "Out of memory trying to alloc var pool.\n");
            exit(1);
        }
        used = 0;
        /* don't free old pool (those vars are still in use) */
    }
    v = &pool[used++];
    v->name = name;
    v->parent = 0;
    return v;
#undef POOLSIZE
}

/* Returns 1 if this is the canonical representative of its
 * equivalence class (i.e., if it is a root in the union-find
 * forest), 0 otherwise. */
static int isroot(struct variable *v) {
    uintptr_t i = (uintptr_t) v->parent;
    // A grody hack.  See defn of struct variable.
    return i < (uintptr_t)4096U;
}
static void setrank(struct variable *v, int rank) {
    assert(0 <= rank && rank < 4096);
    assert(isroot(v));
    v->parent = (struct variable *) (uintptr_t) rank;
}
static int getrank(struct variable *v) {
    assert(isroot(v));
    return (int)(uintptr_t)v;
}
static void setroot(struct variable *v, struct variable *root) {
    struct variable *t;

    while (!isroot(v)) {
        t = v->parent;
        v->parent = root;
        v = t;
    }
}
static struct variable *find(struct variable *v) {
    struct variable *root=v;
    while (!isroot(root))
        root = root->parent;
    setroot(v, root);
    return root;
}
static void do_union(struct variable *v1, struct variable *v2) {
    struct variable *root1=v1, *root2=v2, *newroot;
    int rank1, rank2;
    while (!isroot(root1))
        root1 = root1->parent;
    while (!isroot(root2))
        root2 = root2->parent;
    rank1 = getrank(root1);
    rank2 = getrank(root2);
    if (rank1 < rank2) {
        root1->parent = root2;
        newroot = root2;
    } else if (rank1 > rank2) {
        root2->parent = root1;
        newroot = root1;
    } else if (root1 != root2) {
        // assert(rank1 == rank2);
        root2->parent = root1;
        setrank(root1, rank1+1);
        newroot = root1;
    } else {
        // assert(root1 = root2);
        newroot = root1;
    }
    setroot(v1, newroot);
    setroot(v2, newroot);
}


static unsigned int len_variables = 0, used_variables_times_two = 0;
static struct variable **variables = NULL;
static int findslot(const char *name) {
    unsigned int h = hash(name);
    unsigned int i = h % len_variables;
    unsigned int h2 = (h % (len_variables-1)) + 1;
    while (1) {
        if (variables[i] == NULL)
            return i;
        if (strcmp(variables[i]->name, name) == 0)
            return i;
        i = (i+h2) % len_variables;
    }
}
static void addvariablestruct_internal(struct variable *v) {
    unsigned int i = findslot(v->name);
    if (variables[i] == NULL)
        variables[i] = v;
}
static unsigned int next_prime_length(void) {
    /* The largest prime number less than 2^18, 2^20, 2^22, ..., 2^30, 2^31.
     * Hopefully we'll never have anywhere near that many variables. */
    static unsigned int primes[] = {
        262139, 1048573, 4194301, 16777213, 67108859, 268435399,
        1073741789, 2147483647, 0
    };
    int i;
    for (i=0; primes[i] > 0; i++)
        if (primes[i] > len_variables)
            return primes[i];
    fprintf(stderr, "Out of primes enlarging hashtable.  (old len=%d)\n",
            len_variables);
    exit(1);
}
/* Increase the table size by 4x to make room for more variables,
 * and rehash. */
static void add_capacity(void) {
    struct variable **old_variables = variables;
    unsigned int i, old_len_variables = len_variables;

    len_variables = next_prime_length();
    variables = calloc(len_variables, sizeof(struct variable *));
    if (variables == NULL) {
        fprintf(stderr, "Out of memory enlarging hashtable.  (Tried to allocate %d vars.)\n",
                len_variables);
        exit(1);
    }
    if (old_variables == NULL)
        return;

    /* Rehash the old hashtable entries into the new hashtable. */
    for (i=0; i<old_len_variables; i++)
        if (old_variables[i] != NULL)
            addvariablestruct_internal(old_variables[i]);
    free(old_variables);
}
/* Ensure a load factor of at most 1/2. */
static inline void ensure_capacity(void) {
    if (used_variables_times_two < len_variables)
        return;
    add_capacity();
}
static struct variable *addvariablename(const char *name) {
    unsigned int i;
    ensure_capacity();
    i = findslot(name);
    if (variables[i] != NULL)
        return variables[i];
    used_variables_times_two += 2;
    variables[i] = alloc_variable(mystrdup(name));
    assert(isroot(variables[i]));
    return variables[i];
}
static struct variable *getvariable(const char *name) {
    unsigned int i = findslot(name);
    return variables[i];
}

/* Gets the next non-blank, non-comment line from stdin.
 * Returns a pointer to a static buf (make sure to make your own
 * local copy of it before calling nextline again). */
static char *nextline(void) {
    static char buf[8192];
    char *p, *semicolon, *eol;

 read:
    p = fgets(buf, sizeof buf, stdin);
    if (p == NULL)
        return NULL;
    while (isspace(*p))
        p++;
    if (*p == '\0' || strncmp(p, "XXX", 3) == 0)
	  goto read; // ignore blank lines & comments; try again

    /* Assert: The line didn't get truncated. */
    assert(strchr(p, '\n') != NULL);
    /* Assert: It's either an ASSERT, or a QUERY, or a declaration. */
    assert(strncmp(p, "ASSERT", 6) == 0 || strncmp(p, "QUERY", 5) == 0
            || strchr(p, ':') != NULL);
    semicolon = strchr(p, ';');
    /* Assert: The line ends with ';'. */
    assert(semicolon != NULL);
    for (eol=semicolon+1; isspace(*eol); eol++)
        ;
    assert(eol[0] == '\0');
    semicolon[1] = '\0'; // truncate after the semicolon

    return p;
}

// The equivalence class of all variables that appear in a QUERY
// or are (transitively) related to such a variable.
static struct variable *relevant_vars = NULL;

/* Variable v (or some variable in its equivalence class) was seen
 * in a QUERY.   Mark it and everything else in its equivalence class
 * as 'relevant', for later use. */
static void add_relevant(struct variable *v) {
    assert(v != NULL);
    if (relevant_vars != NULL)
        do_union(v, relevant_vars);
    else
        relevant_vars = v;
}

static int everything_is_relevant = 0;

static void parseline(char *line) {
    struct variable *lastv = NULL, *v;
    char *tok;
    int isquery = strncmp(line, "QUERY", 5) == 0;
    for (tok = strtok(line, delims); tok != NULL; tok = strtok(NULL, delims)) {
            if (isconstant(tok))
                continue;
            if (iskeyword(tok))
                continue;
            if (strcmp(tok, "XXX") == 0)
                break;
            v = addvariablename(tok);
            if (lastv != NULL)
                do_union(v, lastv);
            lastv = v;
    }
    if (isquery) {
        int c;

        if (lastv != NULL)
            add_relevant(lastv);
        else
            everything_is_relevant = 1; // saw QUERY(FALSE) or QUERY(TRUE)

        c = getchar();
        if (c != EOF) {
            fprintf(stderr, "Warning: QUERY wasn't last line of input.\n");
            ungetc(c, stdin);
        }
    }
}

/* Returns 1 if this constraints contains any variable that is
 * in the same equivalence class as any variable in any QUERY;
 * 0 otherwise. */
static int isrelevant(char *line) {
    static char buf[8192];
    struct variable *v;
    char *tok;
    int found_variable = 0;
    assert(strlen(line) < 8192);
    strcpy(buf, line);
    for (tok = strtok(buf, delims); tok != NULL; tok = strtok(NULL, delims)) {
            if (isconstant(tok))
                continue;
            if (iskeyword(tok))
                continue;
            if (strcmp(tok, "XXX") == 0)
                break;
            v = getvariable(tok);
            assert(v != NULL);
            if (find(v) == relevant_vars)
                return 1;
            found_variable = 1;
    }
    if (!found_variable) {
        /* Saw ASSERT(TRUE) or ASSERT(FALSE) or somesuch.
         * Preserve them into the output, to avoid tickling a STP bug
         * (where some QUERYs need to be preceded by an ASSERT). */
        assert(strcmp(line, "ASSERT(TRUE);")==0
                || strcmp(line, "ASSERT(FALSE);")==0
                || strcmp(line, "QUERY(TRUE);")==0
                || strcmp(line, "QUERY(FALSE);")==0);
        return 1;
    }
    return everything_is_relevant;
}

static void check_all_normal(void) {
    unsigned int i;
    for (i=0; i<len_variables; i++)
        if (variables[i] != NULL)
            if (!isnormalname(variables[i]->name))
                fprintf(stderr, "Warning: '%s' doesn't look like a variable name.\n",
                    variables[i]->name);

    /*
    // DEBUG:
    for (i=0; i<len_variables; i++)
        if (variables[i] != NULL)
            if (find(variables[i]) == relevant_vars)
                fprintf(stderr, "DEBUG: '%s' is relevant\n",
                        variables[i]->name);
    */
}

static void goback(void) {
    if (!everything_is_relevant) {
        if (relevant_vars == NULL) {
            fprintf(stderr, "Error: No QUERY seen.\n");
            exit(1);
        }
        relevant_vars = find(relevant_vars);
        assert(find(relevant_vars) == relevant_vars);
    }
    check_all_normal();
    rewind(stdin);
}

int main(void) {
    char *line;

    init_keywords();
    while ((line = nextline()) != NULL) {
        parseline(line);
    }
    goback();
    while ((line = nextline()) != NULL) {
        if (isrelevant(line))
            puts(line);
    }

    return 0;
}

/* Test case based on code snippet from blexim, "Basic Integer Overflows" */ 
/* Catchconv in its current state is not expected to find this bug. */ 

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

    int catvars(char *buf1, char *buf2, unsigned int len1,
                unsigned int len2){

        char * mybuf;
	mybuf = (char *) malloc(sizeof(char)*256); 

        if((len1 + len2) > 256){    /* [3] */
            return -1;
        }

        memcpy(mybuf, buf1, len1);      /* [4] */
        memcpy(mybuf + len1, buf2, len2);

	// This line in blexim's article but not needed here
	//        do_some_stuff(mybuf);

	free(mybuf);
        return 0;
    }

int main(int argc, char **argv) 
{
  char * input;
  char * buf2; 
  int ret;
  int len1, len2; 
  //  FILE *fd = fopen(argv[1], "r"); 
  int fd = open(argv[1], O_RDONLY); 
  input = malloc(sizeof(char)*256); 
  //  fgets(input, 256, fd); 
  read(fd, input, 256); 

  len1 = input[0];
  len2 = input[3]; 
  ret = catvars(input, input, len1, len2); 
  free(input);
  return 0; 
}
